---
layout: doc
---

# 自动生成侧边栏目录



<br>

<el-link ref="https://blog.csdn.net/weixin_46463785/article/details/128592038" target="_blank" type="primary">资源来自--摸鱼老萌新</el-link>



## 1、引入node的path模块

新建一个autoSideBar.js文件，在autoSideBar.js文件内，引入node的path模块

```js
const path = require("path");
```



## 2、安装directory-tree这个库

### npm安装

```js
npm i directory-tree
```

```js
//  我安装的版本是3.5.1
 "dependencies": {
    "@vitepress-demo-preview/component": "^2.3.0",
    "@vitepress-demo-preview/plugin": "^1.1.9",
    "directory-tree": "^3.5.1",
    "element-plus": "^2.3.4"
  }
```

### 引入库

```js
const dirTree = require("directory-tree");
```



## 3、获取指定目录下的文件结构

```js
// 通过使用如下的函数获取指定目录下（/guide）的文件结构
// const srcPath = path.resolve(__dirname,"../guide");

// 把传入的目录下的文件解析的指定的格式方便我们处理
const srcDir = dirTree(srcPath,{
  // 同时处理时我们仅需要留下md格式的文件即可
  extensions: /\.md$/,
  // 配置extensions过滤文件格式
  normalizePath: true,
});
```

 <el-alert
    title="以上代码最终要注释掉"
    type="error"
    description="在下面的autoGetSidebarOptionBySrcDir 函数里面，重新获取了文件结构"
    show-icon
  />


控制台打印测试一下

```js
console.log(srcDir); // 测试完成后删掉
```

```js
// 在vscode的终端，使用node执行autoSideBar.js文件，输出目录
node .\docs\.vitepress\autoSideBar.js 
```

可以看到，解析后我们的得到的数据是这样的：

```js
{
  path: 'D:/Code/PanPanFrontEnd/VitePress/docs/guide',
  name: 'guide',
  children: [
    {
      path: 'D:/Code/PanPanFrontEnd/VitePress/docs/guide/index.md',
      name: 'index.md'
    }
  ]
}
```



## 4、生成侧边栏

```js
function autoGetSidebarOptionBySrcDir (srcPath,title) {
  // srcPath 是传入的文件夹路径
  // title 是生成路径的标题（文件夹叫做“guide”，但是我希望在侧边栏中，它叫做“开始”）

  // 把传入的目录下的文件解析的指定的格式方便我们处理
  const srcDir = dirTree(srcPath,{
    // 同时处理时我们仅需要留下md格式的文件即可
    extensions: /\.md$/,
    // 配置extensions过滤文件格式
    normalizePath: true,
  });

  // 将index.md放最前面
  let firstIndexMD = {};
  srcDir.children.forEach((item,index) => {
    if (item.name === 'index.md') {
      firstIndexMD = item;
      srcDir.children.splice(index,1)
      return;
    }
  })
  srcDir.children.unshift(firstIndexMD);

  return [
    {
      // 如果传入了新的标题，则使用传入的新标题
      text: title == undefined ? srcDir.name : title,
      // 默认展开
      collapsible: true,
      collapsed: true,
      items: toSidebarOption(srcDir.children),
    },
  ];
}

function toSidebarOption (tree = []) {
  // 类型校验，我们需要传入一个数组（必须是数组，否则就乱了）
  if (!Array.isArray(tree)) return [];

  return tree.map((v) => {
    // 判断数组的每一项是不是有children属性，有children则对children递归
    if (v.children !== undefined) {
      return {
        text: v.name,
        // 设置菜单属性（比如能否展开等）
        collapsible: true,
        collapsed: true,
        // 但是我们不知道他有几个子文件夹，所以我们需要通过一个递归函数来解决这个问题
        items: toSidebarOption(v.children),
      };
    } else {
      // 如果没有，那么其可能是空的文件夹或者md文件
      // 使用函数将可能是md文件的.md结尾去掉
      let text = v.name.replace(".md","")
      return {
        // 去掉序号
        // index改成“开始”
        text: text.includes('.') ? text.split('.')[1] : (text == 'index' ? '开始' : text),
        // 传入link属性中，作为我们的访问路径
        // 注意路径是从docs文件夹开始写的绝对路径，不能写成是相对路径的方式
        // 路径path从docs开始截断
        link: v.path.split("docs")[1].replace(".md",""),
      };
    }
  });
}
```



## 5、导出函数

```js
export { autoGetSidebarOptionBySrcDir };
```



## 6、调用函数

在`config.js`里引用函数

```js
import { toSidebarOption,autoGetSidebarOptionBySrcDir } from './autoSideBar'
```



## 7、配置侧边栏

在`themeConfig`中，配置`sidebar`

比如说，我们通过如下的调用形式就把`/guide`的侧边栏配置好了：

```js
themeConfig: {
  // logo: '/logo.png',
  siteTitle: '搭建一个文档',
  outline: 2, // 默认2级标题
  socialLinks: [
    { icon: 'github',link: 'https://github.com/vuejs/vitepress' }
  ],
  nav,
  sidebar: {
    "/guide": autoGetSidebarOptionBySrcDir(
      path.resolve(__dirname,"../guide"),
      "开始"
    ),
  }
},
```



## 8、侧边栏多个项目

当然如果你的侧边栏中有多个项的话，比如说你在`docs`下面想放上多个文件夹，那么使用`concat`来连接数组就行了

```js
sidebar: {
  "/": autoGetSidebarOptionBySrcDir(path.resolve(__dirname,"../04-js深入"))
    .concat(autoGetSidebarOptionBySrcDir(path.resolve(__dirname,"../09-VitePress"))),
}
```



这样编写的好处在于：

我们可以更新后让系统自动给我们配置目录

同时你也可以把资料放在不同的位置但是生成在一个侧边下方，完全根据你的喜好来配置

