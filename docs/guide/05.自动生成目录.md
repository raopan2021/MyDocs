# 自动生成侧边栏目录



<br>

  <el-alert title="资源来自： https://blog.csdn.net/weixin_46463785/article/details/128592038" type="info" show-icon />



## 1、引入node的path模块

新建一个autoSideBar.js文件，在autoSideBar.js文件内，引入node的path模块

```js
const path = require("path");
```



## 2、安装directory-tree这个库

### npm安装

```js
npm i directory-tree
```

```js
//  我安装的版本是3.5.1
 "dependencies": {
    "@vitepress-demo-preview/component": "^2.3.0",
    "@vitepress-demo-preview/plugin": "^1.1.9",
    "directory-tree": "^3.5.1",
    "element-plus": "^2.3.4"
  }
```

### 引入库

```js
const dirTree = require("directory-tree");
```



## 3、获取指定目录下的文件结构

```js
// 通过使用如下的函数获取指定目录下（/guide）的文件结构
// const srcPath = path.resolve(__dirname,"../guide");

// 把传入的目录下的文件解析的指定的格式方便我们处理
// 同时处理时我们仅需要留下md格式的文件即可
// 配置extensions过滤文件格式
// const srcDir = dirTree(srcPath,{
//   extensions: /\.md$/,
//   normalizePath: true,
// });
```


 <el-alert
    title="以上代码最终要注释掉"
    type="error"
    description="在下面的autoGetSidebarOptionBySrcDir 函数里面，重新获取指定目录下的文件结构，并且进行了优化（将index.md放最前面）"
    show-icon
  />


控制台打印测试一下

```js
console.log(srcDir); // 测试完成后删掉
```

```js
// 在vscode的终端，使用node执行autoSideBar.js文件，输出目录
node .\docs\.vitepress\autoSideBar.js 
```

可以看到，解析后我们的得到的数据是这样的：

```js
{
  path: 'D:/Code/PanPanFrontEnd/VitePress/docs/guide',
  name: 'guide',
  children: [
    {
      path: 'D:/Code/PanPanFrontEnd/VitePress/docs/guide/index.md',
      name: 'index.md'
    }
  ]
}
```



## 4、生成侧边栏

```js
function toSidebarOption (tree = []) {
  // 类型校验，我们需要传入一个数组（必须是数组，否则就乱了）
  if (!Array.isArray(tree)) return [];

  return tree.map((v) => {
    // 之后判断数组的每一项是不是有children属性，
    // 那么把它的children传入继续递归，并且设置其菜单的其他属性（比如能否展开等）
    if (v.children !== undefined) {
      return {
        text: v.name,
        collapsible: true,
        collapsed: true,
        // 但是我们不知道他有几个子文件夹，所以我们需要通过一个递归函数来解决这个问题
        items: toSidebarOption(v.children),
      };
    } else {
      // 如果没有，那么其可能是空的文件夹或者md文件
      // 使用函数将可能是md文件的.md结尾去掉，再将路径path从docs开始截断
      // 注意路径是从docs文件夹开始写的绝对路径，不能写成是相对路径的方式
      return {
        text: v.name.replace(".md",""),
        // 传入link属性中，作为我们的访问路径
        link: v.path.split("docs")[1].replace(".md",""),
      };
    }
  });
}
```

这个时候注意到一个问题，比如说我的文件夹叫做“guide”，但是我希望在侧边栏中，它叫做“开始”，怎么处理呢？

修改一下我们的传入函数，拓展它自定义目录名称的能力就行了，设置title属性，如果我们传入的title那么我们按照title生成目录，最后的函数如下：

```js
function autoGetSidebarOptionBySrcDir (srcPath,title) {
  const srcDir = dirTree(srcPath,{
    extensions: /\.md$/,
    normalizePath: true,
  });

  // 将index.md放最前面
  let firstIndexMD = {};
  srcDir.children.forEach((item,index) => {
    if (item.name === 'index.md') {
      firstIndexMD = item;
      srcDir.children.splice(index,1)
      return;
    }
  })
  srcDir.children.unshift(firstIndexMD);
    
  return [
    {
      // 如果传入了新的标题，则使用传入的新标题
      text: title == undefined ? srcDir.name : title,
      // 默认展开
      collapsible: true,
      collapsed: true,
      items: toSidebarOption(srcDir.children),
    },
  ];
}
```



## 5、导出函数

```js
export { autoGetSidebarOptionBySrcDir };
```



## 6、调用函数

在config.js里引用函数

```js
import { toSidebarOption,autoGetSidebarOptionBySrcDir } from './autoSideBar'
```



## 7、配置侧边栏

在themeConfig中，配置sidebar

比如说，我们通过如下的调用形式就把"/guide"的侧边栏配置好了：

```js
  themeConfig: {
    // logo: '/logo.png',
    siteTitle: '搭建一个文档',
    outline: 3,
    socialLinks: [
      { icon: 'github',link: 'https://github.com/vuejs/vitepress' }
    ],
    nav,
    sidebar: {
      "/guide": autoGetSidebarOptionBySrcDir(
        path.resolve(__dirname,"../guide"),
        "开始"
      ),
    }
  },
```

当然如果你的侧边栏中有多个项的话，比如说你在other下面想放上多个文件夹，那么使用concat来连接数组就行了

```js
autoGetSidebarOptionBySrcDir(
    path.resolve(__dirname, "../guide"),
    "开始"
  ).concat(autoGetSidebarOptionBySrcDir(
    path.resolve(__dirname, "../components"),
    "组件"
  ))
```



这样编写的好处在于：

我们可以更新后让系统自动给我们配置目录

同时你也可以把资料放在不同的位置但是生成在一个侧边下方，完全根据你的喜好来配置

